#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# -----------------------------------------------------------------------------
# Copyright (c) 2025 IKI CLOUD
#
# This software is provided by IKI CLOUD for demonstration and proof-of-concept (POC) purposes.
# You are free to use, modify, and distribute this code under the MIT License.
#
# IMPORTANT:
# These scripts are intended for evaluation and educational use.
# If you plan to adapt or deploy them in production environments,
# please contact the IKI CLOUD team first at info@iki-cloud.com.
#
# This project makes use of third-party libraries including Oracle Python SDKs
# (e.g., `oci`, `oracledb`), which are distributed under their own licenses.
# Please refer to their respective license terms for details.
# -----------------------------------------------------------------------------

"""
IngestPdfText.py
----------------
Purpose:
  1) Extract the FULL text from a PDF using your local library `TextExtraction.py`
  2) Insert (filename, text) into `GENAI_USER.DOCUMENT_RAW` (CLOB column FILETEXT)
  
Notes:
  - `TextExtraction.main(pdf_path)` MUST return a string or a list[str].
  - This script performs NO chunking and NO embeddings. It only ingests raw text.
  - Chunking + embeddings will be handled later in the database via a stored procedure.
"""

import os
import hashlib
import oracledb
import TextExtraction  # your library that talks to OCI Document Understanding

# === Database configuration ===
DB_DSN  = "tirocinio-2025:1521/FREEPDB1"  # host:port/SERVICE_NAME
DB_USER = "GENAI_USER"
DB_PASS = "GENAI_USER"

def get_db_conn():
    """
    Open a connection to Oracle Database using python-oracledb.
    The DSN/user/password are defined above for simplicity.
    """
    return oracledb.connect(user=DB_USER, password=DB_PASS, dsn=DB_DSN)

def extract_full_text(pdf_path: str) -> str:
    """
    Extract the FULL text from the given PDF path by invoking your TextExtraction library.
    It accepts both str and list[str] returned by TextExtraction.main() and normalizes it to str.
    Raises:
      - TypeError if the returned object is not str or list[str]
      - ValueError if empty text is produced
    """
    txt = TextExtraction.main(pdf_path)  # expected to print AND return the extracted text
    if isinstance(txt, list):
        txt = "\n".join([s for s in txt if isinstance(s, str)])
    if not isinstance(txt, str):
        raise TypeError("TextExtraction.main must return str or list[str].")
    txt = txt.strip()
    if not txt:
        raise ValueError("No text extracted from the PDF.")
    return txt

def sha256_hex(s: str) -> str:
    """
    Compute a stable SHA-256 fingerprint of the text. Useful for deduplication.
    """
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def insert_document(pdf_path: str, dedupe_by_filename: bool = True) -> int:
    """
    Insert the PDF content into GENAI_USER.DOCUMENT_RAW.

    Parameters:
      - pdf_path: path to the PDF to ingest
      - dedupe_by_filename: if True, delete any existing row with the same filename before inserting

    Returns:
      - new ID (int) generated by the identity column
    """
    if not os.path.exists(pdf_path):
        raise FileNotFoundError(f"File not found: {pdf_path}")

    filename = os.path.basename(pdf_path)
    filetext = extract_full_text(pdf_path)
    digest   = sha256_hex(filetext)

    conn = get_db_conn()
    try:
        with conn.cursor() as cur:
            # Prepare a CLOB bind variable for robust large text insertion
            clob_var = cur.var(oracledb.DB_TYPE_CLOB)
            clob_var.setvalue(0, filetext)

            if dedupe_by_filename:
                # Keep only the latest version of a given filename
                cur.execute(
                    "DELETE FROM GENAI_USER.DOCUMENT_RAW WHERE FILENAME = :fn",
                    {"fn": filename}
                )

            # Return the generated ID via RETURNING INTO
            id_var = cur.var(oracledb.DB_TYPE_NUMBER)
            cur.execute(
                """
                INSERT INTO GENAI_USER.DOCUMENT_RAW (FILENAME, FILETEXT, DOC_SHA256)
                VALUES (:fn, :tx, :sha)
                RETURNING ID INTO :id_out
                """,
                {"fn": filename, "tx": clob_var, "sha": digest, "id_out": id_var}
            )
            conn.commit()

            # python-oracledb returns a list-like object for RETURNING INTO
            new_id = int(id_var.getvalue()[0])
            print(f"[OK] Inserted '{filename}' as ID={new_id} (SHA256={digest[:12]}...)")
            return new_id
    finally:
        conn.close()

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python IngestPdfText.py <file.pdf>")
        raise SystemExit(1)
    insert_document(sys.argv[1])
